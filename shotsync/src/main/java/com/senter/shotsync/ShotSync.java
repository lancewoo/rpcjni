// Targeted by JavaCPP version 1.5.8: DO NOT EDIT THIS FILE

package com.senter.shotsync;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class ShotSync extends com.senter.shotsync.NativeLibraryConfig {
    static { Loader.load(); }

// Parsed from stc_rpc.h

/**
 * This file is part of stc-rpc.
 *
 * Copyright (C) 2012 Alexander Tarasikov <alexander.tarasikov\gmail.com>
 *
 * stc-rpc is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * stc-rpc is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with stc-rpc.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// #ifndef __STC_RPC_H__
// #define __STC_RPC_H__

// #include "stc_log.h"

public static final int RPC_TIMEOUT_US = (1000 * 500);
// #ifndef RPC_PAYLOAD_MAX
public static final int RPC_PAYLOAD_MAX = (2048);
// #endif

public static class rpc_request_hdr_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public rpc_request_hdr_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public rpc_request_hdr_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public rpc_request_hdr_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public rpc_request_hdr_t position(long position) {
        return (rpc_request_hdr_t)super.position(position);
    }
    @Override public rpc_request_hdr_t getPointer(long i) {
        return new rpc_request_hdr_t((Pointer)this).offsetAddress(i);
    }

	public native @Cast("unsigned") int code(); public native rpc_request_hdr_t code(int setter);
	public native @Cast("char") byte buffer(int i); public native rpc_request_hdr_t buffer(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer buffer();
}

public static class rpc_reply_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public rpc_reply_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public rpc_reply_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public rpc_reply_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public rpc_reply_t position(long position) {
        return (rpc_reply_t)super.position(position);
    }
    @Override public rpc_reply_t getPointer(long i) {
        return new rpc_reply_t((Pointer)this).offsetAddress(i);
    }

	public native @Cast("unsigned") int code(); public native rpc_reply_t code(int setter);	
	public native @Cast("char") byte buffer(int i); public native rpc_reply_t buffer(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer buffer();
}

public static class rpc_request_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public rpc_request_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public rpc_request_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public rpc_request_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public rpc_request_t position(long position) {
        return (rpc_request_t)super.position(position);
    }
    @Override public rpc_request_t getPointer(long i) {
        return new rpc_request_t((Pointer)this).offsetAddress(i);
    }

	public native @ByRef rpc_request_hdr_t header(); public native rpc_request_t header(rpc_request_hdr_t setter);
	public native @ByRef rpc_reply_t reply(); public native rpc_request_t reply(rpc_reply_t setter);
	
	public native IntPointer reply_marker(); public native rpc_request_t reply_marker(IntPointer setter);
}

public static class rpc_handler_t extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    rpc_handler_t(Pointer p) { super(p); }
    protected rpc_handler_t() { allocate(); }
    private native void allocate();
    public native int call(rpc_request_hdr_t hdr, rpc_reply_t reply);
}

@Opaque public static class rpc extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public rpc() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public rpc(Pointer p) { super(p); }
}
@Opaque public static class rpc_t extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public rpc_t() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public rpc_t(Pointer p) { super(p); }
}

// #define RPC_PACK_RAW(buffer, idx, pvalue, size) do {
// 	if (idx + size >= RPC_PAYLOAD_MAX) {
// 		RPC_ERROR("data too large");
// 		goto fail;
// 	}
// 	memcpy(buffer + idx, pvalue, size);
// 	idx += size;
// } while (0)

// #define RPC_PACK(buffer, idx, value)
// 	RPC_PACK_RAW(buffer, idx, &value, sizeof(value))

// #define RPC_PACK_S(buffer, idx, str) do {
// 	size_t __len = strlen(str) + 1;
// 	RPC_PACK_RAW(buffer, idx, str, __len);
// } while (0)

// #define RPC_UNPACK_RAW(buffer, idx, pvalue, size) do {
// 	if (idx + size >= RPC_PAYLOAD_MAX) {
// 		RPC_ERROR("data too large : %d bytes", idx + size);
// 		goto fail;
// 	}
// 	memcpy(pvalue, buffer + idx, size);
// 	idx += size;
// } while (0)

// #define RPC_UNPACK(buffer, idx, value)
// 	RPC_UNPACK_RAW(buffer, idx, &value, sizeof(value))

// #define RPC_UNPACK_S(buffer, idx, str) do {
// 	size_t __len = strlen(buffer + idx) + 1;
// 	RPC_UNPACK_RAW(buffer, idx, str, __len);
// } while (0)


/*
 * @brief Allocates the rpc structure
 *
 * @return pointer to the allcated structure
 * @return NULL in case of a failure
 */
@NoException public static native rpc_t rpc_alloc();


/*
 * @brief De-allocates the rpc structure
 *
 * @param rpc The pointer to the rpc structure or NULL
 */
@NoException public static native void rpc_free(rpc_t rpc);

/*
 * @brief initializes the RPC structure
 *
 * @param fd the file descriptor of a socket for rpc
 * this must be a two-way socket, not a pipe
 * this function sets the file descriptor into a NONBLOCK mode
 * @param handler the pointer to the callback processing RPC messages
 * @param rpc the pointer to the structure to setup
 *
 * @return zero (0) in case of success
 * @return negative error code in case of a failure
 */
@NoException public static native int rpc_init(int fd, rpc_handler_t handler, rpc_t rpc);

/*
 * @brief Performs the RPC call and blocks until reply is received if
 * the RPC procedure is supposed to return a value
 *
 * @return zero (0) in case of success
 * @return negative error code in case of a failure
 */
@NoException public static native int rpc_call(rpc_t rpc, rpc_request_t req);

/*
 * @brief Performs the RPC call and returns immediately without waiting
 * for the request to complete
 *
 * @return zero (0) in case of success
 * @return negative error code in case of a failure
 */
@NoException public static native int rpc_call_noreply(rpc_t rpc, rpc_request_t req);

/*
 * @brief starts the RPC worker thread
 *
 * @param rpc the pointer to the rpc_init'ed RPC structure
 *
 * @return zero (0) in case of success
 * @return negative error code in case of a failure
 */
@NoException public static native int rpc_start(rpc_t rpc);

/*
 * @brief waits for the rpc thread to complete
 *
 * @param rpc the pointer to the rpc_init'ed RPC structure
 *
 * @return zero (0) in case of success
 * @return negative error code in case of a failure
 */
//int rpc_join(rpc_t *rpc);

/*
 * @brief stops the rpc thread
 *
 * @param rpc the pointer to the rpc_init'ed RPC structure
 *
 * @return zero (0) in case of success
 * @return negative error code in case of a failure
 */
@NoException public static native int rpc_stop(rpc_t rpc);

// #endif //__STC_RPC_H__


// Parsed from RpcImpl.h

// #ifndef CAMERASHOTSYNC_RPCIMPL_H
// #define CAMERASHOTSYNC_RPCIMPL_H
// #ifdef __cplusplus
// #endif

// #include "libstc-rpc/include/stc_rpc.h"

    @Namespace("client") public static native void ClientSetMessageHandler(rpc_handler_t userHandler);



// #ifdef __cplusplus
// #endif
// #endif //CAMERASHOTSYNC_RPCIMPL_H


}
